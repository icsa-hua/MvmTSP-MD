import deap 
from deap import base, creator, tools, algorithms 
import pandas as pd 
import random 
import time 
import numpy
import pdb
import numpy as np



V_nodes = list(range(36))
v = len(V_nodes)
agents = [1,2,3]
m = len(agents)
population_size = 100 
generations = 50 
D = [V_nodes[8],V_nodes[9]] 


def evaluate(individual, c_ij,m):
    total_distance = 0 
    tours = split_tours(individual, m, D)
    for tour in tours: 
        distance = 0
        
        for i in range(len(tour)-1):
            distance += c_ij[tour[i]][tour[i+1]]
        distance += c_ij[tour[-1]][tour[0]]
        total_distance += distance 
    return (total_distance,) 

def initialization_GA():
    creator.create("FitnessMin", base.Fitness,weights=(-1.0,))
    creator.create("Individual", list, fitness=creator.FitnessMin)

def split_tours(individual, m, D ): 
    size_per_agent = len(individual) // m
    tours = []
    d = D[np.random.randint(2)]
    for i in range(m):
        start = i * size_per_agent
        end = len(individual) if i == m - 1 else (i + 1) * size_per_agent
        tour = [d] + individual[start:end] + [d]
        tours.append(tour)
    return tours

def toolbox_config(v,distances,m,): 
    toolbox = base.Toolbox() 
    toolbox.register("indices", random.sample, list(range(v)), v)
    toolbox.register("individual", tools.initIterate, creator.Individual, toolbox.indices)
    toolbox.register("population", tools.initRepeat, list, toolbox.individual)
    pdb.set_trace()
    for ind in toolbox.population:
        if ind[0] not in D or ind[-1] not in D: 
            toolbox.population.pop(ind)
    toolbox.register("mate", tools.cxPartialyMatched)
    toolbox.register("mutate", tools.mutShuffleIndexes, indpb=0.05)
    toolbox.register("select", tools.selTournament, tournsize=3)
    toolbox.register("evaluate", evaluate, c_ij=distances,m=m)
    return toolbox 

def ga_execution(population_size, generations, toolbox,distances,m): 
    hof   = tools.ParetoFront()
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", numpy.mean, axis=0)
    stats.register("std", numpy.std, axis=0)
    stats.register("min", numpy.min, axis=0)
    stats.register("max", numpy.max, axis=0)
    population = toolbox.population(n=population_size)
    algorithms.eaSimple(population, toolbox, cxpb=0.7, mutpb=0.2, ngen=generations, stats=stats, halloffame=hof, verbose=True)

    best_paths = tools.selBest(population, m*m)
    for i, path in enumerate(best_paths): 
        print(f"Path for agent {i+1}: {path}")

    return best_paths, hof


distances = pd.read_csv('../distance_cost.csv')
distances = distances.to_numpy().astype(int)

initialization_GA()
toolbox = toolbox_config(v,distances,m=m)
_, hof = ga_execution(population_size=population_size, generations=generations, toolbox=toolbox,distances=distances,m=m)
print(hof)












